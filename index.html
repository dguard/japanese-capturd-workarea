<html>
<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
	<style>
		body {
			margin: 0
		}
		.capturd-workarea {
			margin-top: calc(/* keep height */ -100%);
		}

		.statement-area-through-knot .statement-at-front-through-knot #scene-through-knot {
			height: 100vh;
		}
	  	.statement-area .statement-at-front #scene {
	      width: 100vw;
	      height: 821px;
	      /*height: calc((2 + 1) * 100vh);*/
	      z-index: calc(/* keep draft-workarea */ 4);
	      	margin-top: -821px;
			/*margin-top: calc((2 + 1) *-100vh);*/
	  	}
	  	.sample-slot-hand-another.into-focus {
        position: static;
	  		z-index: 1;

        margin-top: -581px;
        margin-left: 1109px;
	  	}
	  	.sample-slot-hand-another {
        position: absolute;
	  		float: left;
	  	}
	  	.sample-slot-hand.into-focus {
        position: static;
	  		z-index: 1;

        margin-top: -581px;
        margin-left: 1109px;
	  	}
	  	.sample-slot-hand {
        position: absolute;
	  		float: left;
	  	}
	  	.sample-slot-foot-another.into-focus {

        position: static;
	  		z-index: 1;

        margin-top: -581px;
        margin-left: 1109px;
	  	}
      .sample-slot-foot-another-from-original {
        position: absolute;
        /* fromY: 246, fromX: 1119*/
        top: 238px;
      left: 1107px;

      }
	  	.sample-slot-foot-another {

        position: absolute;
	  		float: left;
	  	}
	  	.sample-slot-foot.into-focus {
        position: static;
	  		/*z-index: 1;*/
        margin-top: -581px;
        margin-left: 1109px;
	  	}
      .sample-slot-foot-from-original {
        position: absolute;
        /* fromY: 246, fromX: 1119*/
        top: 238px;
        left: 1107px;
      }
      .sample-slot-foot {
        position: absolute;
        float: left;
	  	}
	  	.draft-workarea {
			z-index: calc(/* keep 1 */ /* 4 */ 1);
			margin-top: -100vh;
	  	}

	</style>
</head>
<body>











<!-- through stickd-album line and through boundin and through debth; from rect and through layer -->
<!-- through knot-locate foot -->

<!-- into compute rotatin -->
<!-- from compute character -->

<!-- into compute character -->
<!-- from choose debth -->

<!-- into choose debth -->
<!-- from choose layer -->

<!-- into choose layer -->
<!-- from choose foot -->

<!-- from draft -->
<img class="capturd-workarea" src="core-lib/sample-vertical-bounce-handler-through-compute.png">

	<div class="statement-area-through-knot">
			<!-- keep -->
			<!-- follow #vertical-bounce-handler-at-terra-knot-from-bottom-statement-from-locate-statement-through-stacking -->
		<div class="statement-at-front-through-knot">
      
			<canvas id="scene-through-knot"></canvas>
		</div>
	</div>
<img class="draft-workarea" src="core-lib/sample-vertical-bounce-handler-through-compute.png">


<div class="statement-area">
		<!-- keep -->
		<!-- follow #vertical-bounce-handler-at-terra-knot-from-bottom-statement-from-locate-statement-through-stacking -->
	<div class="statement-at-front">
		<canvas id="scene"></canvas>
	</div>
</div>

<img class="sample-slot-hand-another" src="core-lib/sample-slot-hand-another.png">
<img class="sample-slot-hand" src="core-lib/sample-slot-hand.png">
<img class="sample-slot-foot-another" src="core-lib/sample-slot-foot-another.png">
<img class="sample-slot-foot into-focus" src="core-lib/sample-slot-foot.png">

<div class="statement-area-from-original">
		<!-- keep -->
		<!-- follow #vertical-bounce-handler-at-terra-knot-from-bottom-statement-from-locate-statement-through-stacking -->
		<div class="statement-at-front-from-original">

			<canvas id="scene-from-original"></canvas>
		</div>
</div>
<!-- <script src="core-lib/from-knot-locate/draft-handle-sample-from-knot-locate.js"></script> -->
<script src="core-lib/from-knot-locate/draft-compact-sample-from-knot-locate.js"></script>
<script src="core-lib/from-knot-locate/draft-sample-from-knot-locate.js"></script>
<script src="core-lib/from-knot-locate/handle-sample-from-knot-locate.js"></script>

<!-- keep ! -->
<!--    <script src="core-lib/js/viewported-knot-at-locate-knot-from-bottom-statement/draft-handle-knot-from-cubic-project.js"></script>-->
<script src="core-lib/js/viewported-knot-locate-from-front/draft-compact-viewported-knot-locate-from-front.js"></script>
<script src="core-lib/js/viewported-knot-locate-from-front/draft-handle-viewported-knot-locate-from-front.js"></script>
<script src="core-lib/js/viewported-knot-locate-from-front/viewported-knot-at-pub.js"></script>



<script>
	let pencil = new Pencil()

    let draftFabrikk = new DraftFabrikk()


    let bottomStatement = draftFabrikk.constructBottomStatement()
    let sceneWalkingAroundLabirintAtStart = new SceneWalkingAroundLabirintAtStart()


    function SampleFromKnotLocate() {
        let that = this

        // keep !
        let spawnedPointerBelongings = { y: 460.29801062650074, x: 29.984574863067234, z: 0.027998035964756942, radius: 30, d: 0.9, f: 0.4, frontRatio: 1, debthScaleRatio: 1, frontScaleRatio: 1, profileScaleRatio: 1 }

        // let spawnedPointerBelongings = { y: 508.427650910673, x: 112.49116883677065, z: 0.0347994541654302, radius: 30, d: 0.9, f: 0.4, frontRatio: 1, debthScaleRatio: 1, frontScaleRatio: 1, profileScaleRatio: 1 }

        let passThrough = window['@pencil/draft-sample-from-knot-locate']['passThrough']

        that.passThrough = passThrough

        that.spawnedPointerBelongings = spawnedPointerBelongings
    }
	
    pencil.rememberSample(sceneWalkingAroundLabirintAtStart, new SampleFromKnotLocate())
    pencil.useScene(sceneWalkingAroundLabirintAtStart)

    let knotSampleFromKnotLocate = pencil.constructKnot()
    // keep up !
    draftFabrikk.connectKnotToBottomStatement(bottomStatement, knotSampleFromKnotLocate)
    pencil.putKnotConnectedToBottomStatement(knotSampleFromKnotLocate)


    pencil.draw()

    // through draft

    let canvas = document.querySelector('.statement-area').querySelector('.statement-at-front').querySelector('#scene')
  	let ctx = canvas.getContext('2d')


      let fromCtx = function(ctx) {

          return {
              moveTo: function(y, x) {
                  return ctx.moveTo(x, y)
              },
              lineTo: function(y, x) {
                  return ctx.lineTo(x, y)
              },

              // keep
              arcTo: function(y1, x1, y2, x2, radius) {
                  return ctx.arcTo(x1, y1, x2, y2, radius)
              },
              ellipse: function(y, x, yRadius, xRadois, rotation, startAngle, endAngle) {
                  return ctx.ellipse(x, y, xRadois, yRadius, rotation, startAngle, endAngle)
              },
              // keep !

              fillRect: function(y, x, knotWi, profile) {
                  ctx.fillStyle = '#fff'
                  return ctx.clearRect(x, y - profile, knotWi, profile)
              }

          }
      }

      // keep
	  let calc = function(expression) {
	  	return expression
	  }

      let throughStacking = function(fromY) {
          // keep
          // calc(fromY /* keep */ + 20)
          return fromY
      }


      let constructKnotSampleThroughHighlightAbove = function(knotConstructionFromStarting) {
      // keep
      for(let k = 0; k < knotConstructionFromStarting.slice(1).length; k++) {
        ctx.beginPath()
        ctx.strokeStyle = '#008080'

        fromCtx(ctx).moveTo(knotConstructionFromStarting[k].fromY, knotConstructionFromStarting[k].fromX)
        fromCtx(ctx).lineTo(knotConstructionFromStarting[k+1].fromY, knotConstructionFromStarting[k+1].fromX)


        ctx.stroke()
      }
      // ctx.stroke()
    }

      let constructKnotSampleThroughDraft = function(knotConstructionFromStarting) {
      // keep
      for(let k = 0; k < knotConstructionFromStarting.slice(1).length; k++) {
        ctx.beginPath()
        ctx.strokeStyle = '#dcdcdc'

        fromCtx(ctx).moveTo(knotConstructionFromStarting[k].fromY, knotConstructionFromStarting[k].fromX)
        fromCtx(ctx).lineTo(knotConstructionFromStarting[k+1].fromY, knotConstructionFromStarting[k+1].fromX)


        ctx.stroke()
      }
      // ctx.stroke()
    }


      let constructKnotSampleThroughHighlight = function(knotConstructionFromStarting) {
      // keep
      for(let k = 0; k < knotConstructionFromStarting.slice(1).length; k++) {
        ctx.beginPath()
        ctx.strokeStyle = '#1e92ff'

        fromCtx(ctx).moveTo(knotConstructionFromStarting[k].fromY, knotConstructionFromStarting[k].fromX)
        fromCtx(ctx).lineTo(knotConstructionFromStarting[k+1].fromY, knotConstructionFromStarting[k+1].fromX)


        ctx.stroke()
      }
      // ctx.stroke()
    }

      let constructKnotSample = function(knotConstructionFromStarting) {
      // keep
      for(let k = 0; k < knotConstructionFromStarting.slice(1).length; k++) {
        ctx.beginPath()
        ctx.strokeStyle = '#000'

        fromCtx(ctx).moveTo(knotConstructionFromStarting[k].fromY, knotConstructionFromStarting[k].fromX)
        fromCtx(ctx).lineTo(knotConstructionFromStarting[k+1].fromY, knotConstructionFromStarting[k+1].fromX)


        ctx.stroke()
      }
      // ctx.stroke()
    }


      // keep !
      let constructKnotThroughHighlightAbove = function(knotSample) {

        ctx.beginPath()

        ctx.strokeStyle = '#008080'

        let [y0, x0] = [knotSample.fromBottomLeft.fromY, knotSample.fromBottomLeft.fromX]
        let [yFromBottomRight, xFromBottomRight] = [knotSample.fromBottomRight.fromY, knotSample.fromBottomRight.fromX]

        fromCtx(ctx).moveTo(throughStacking(y0), x0)
        fromCtx(ctx).lineTo(throughStacking(yFromBottomRight), xFromBottomRight)

        let [yFromTopRight, xFromTopRight] = [throughStacking(knotSample.fromTopRight.fromY), knotSample.fromTopRight.fromX]

        fromCtx(ctx).moveTo(throughStacking(yFromBottomRight), xFromBottomRight)
        fromCtx(ctx).lineTo(throughStacking(yFromTopRight), xFromTopRight)

        let [yFromTopLeft, xFromTopLeft] = [throughStacking(knotSample.fromTopLeft.fromY), knotSample.fromTopLeft.fromX]

        fromCtx(ctx).moveTo(throughStacking(yFromTopRight), xFromTopRight)
        fromCtx(ctx).lineTo(throughStacking(yFromTopLeft), xFromTopLeft)

        // keep
        fromCtx(ctx).moveTo(throughStacking(yFromTopLeft), xFromTopLeft)
        fromCtx(ctx).lineTo(throughStacking(y0), x0)

        ctx.stroke()
    }


      let constructKnotThroughDraft = function(knotSample) {

        ctx.beginPath()

        ctx.strokeStyle = '#dcdcdc'

        let [y0, x0] = [knotSample.fromBottomLeft.fromY, knotSample.fromBottomLeft.fromX]
        let [yFromBottomRight, xFromBottomRight] = [knotSample.fromBottomRight.fromY, knotSample.fromBottomRight.fromX]

        fromCtx(ctx).moveTo(throughStacking(y0), x0)
        fromCtx(ctx).lineTo(throughStacking(yFromBottomRight), xFromBottomRight)

        let [yFromTopRight, xFromTopRight] = [throughStacking(knotSample.fromTopRight.fromY), knotSample.fromTopRight.fromX]

        fromCtx(ctx).moveTo(throughStacking(yFromBottomRight), xFromBottomRight)
        fromCtx(ctx).lineTo(throughStacking(yFromTopRight), xFromTopRight)

        let [yFromTopLeft, xFromTopLeft] = [throughStacking(knotSample.fromTopLeft.fromY), knotSample.fromTopLeft.fromX]

        fromCtx(ctx).moveTo(throughStacking(yFromTopRight), xFromTopRight)
        fromCtx(ctx).lineTo(throughStacking(yFromTopLeft), xFromTopLeft)

        // keep
        fromCtx(ctx).moveTo(throughStacking(yFromTopLeft), xFromTopLeft)
        fromCtx(ctx).lineTo(throughStacking(y0), x0)

        ctx.stroke()

        ctx.strokeStyle = '#000'

    }

      // keep !
      let constructKnotThroughHighlight = function(knotSample) {

        ctx.beginPath()

        ctx.strokeStyle = '#1e92ff'

        let [y0, x0] = [knotSample.fromBottomLeft.fromY, knotSample.fromBottomLeft.fromX]
        let [yFromBottomRight, xFromBottomRight] = [knotSample.fromBottomRight.fromY, knotSample.fromBottomRight.fromX]

        fromCtx(ctx).moveTo(throughStacking(y0), x0)
        fromCtx(ctx).lineTo(throughStacking(yFromBottomRight), xFromBottomRight)

        let [yFromTopRight, xFromTopRight] = [throughStacking(knotSample.fromTopRight.fromY), knotSample.fromTopRight.fromX]

        fromCtx(ctx).moveTo(throughStacking(yFromBottomRight), xFromBottomRight)
        fromCtx(ctx).lineTo(throughStacking(yFromTopRight), xFromTopRight)

        let [yFromTopLeft, xFromTopLeft] = [throughStacking(knotSample.fromTopLeft.fromY), knotSample.fromTopLeft.fromX]

        fromCtx(ctx).moveTo(throughStacking(yFromTopRight), xFromTopRight)
        fromCtx(ctx).lineTo(throughStacking(yFromTopLeft), xFromTopLeft)

        // keep
        fromCtx(ctx).moveTo(throughStacking(yFromTopLeft), xFromTopLeft)
        fromCtx(ctx).lineTo(throughStacking(y0), x0)

        ctx.stroke()
    }

      let constructKnot = function(knotSample) {

          ctx.beginPath()
          ctx.strokeStyle = '#000'

          let [y0, x0] = [knotSample.fromBottomLeft.fromY, knotSample.fromBottomLeft.fromX]
          let [yFromBottomRight, xFromBottomRight] = [knotSample.fromBottomRight.fromY, knotSample.fromBottomRight.fromX]

          fromCtx(ctx).moveTo(throughStacking(y0), x0)
          fromCtx(ctx).lineTo(throughStacking(yFromBottomRight), xFromBottomRight)

          let [yFromTopRight, xFromTopRight] = [throughStacking(knotSample.fromTopRight.fromY), knotSample.fromTopRight.fromX]

          fromCtx(ctx).moveTo(throughStacking(yFromBottomRight), xFromBottomRight)
          fromCtx(ctx).lineTo(throughStacking(yFromTopRight), xFromTopRight)

          let [yFromTopLeft, xFromTopLeft] = [throughStacking(knotSample.fromTopLeft.fromY), knotSample.fromTopLeft.fromX]

          fromCtx(ctx).moveTo(throughStacking(yFromTopRight), xFromTopRight)
          fromCtx(ctx).lineTo(throughStacking(yFromTopLeft), xFromTopLeft)

          // keep
          fromCtx(ctx).moveTo(throughStacking(yFromTopLeft), xFromTopLeft)
          fromCtx(ctx).lineTo(throughStacking(y0), x0)

          ctx.stroke()
      }
    // keep

    let knotHead = {
		fromTopLeft: { fromY: 286, fromX: 565 },
    	fromTopRight: { fromY: 286, fromX: 585 },
		fromBottomRight: { fromY: 359, fromX: 584 },
		fromBottomLeft: { fromY: 359, fromX: 565 }
    }

    let knotBody = {
		fromTopLeft: { fromY: 345, fromX: 597 },
    	fromTopRight: { fromY: 344, fromX: 615 },
		fromBottomRight: { fromY: 418, fromX: 616 },
		fromBottomLeft: { fromY: 418, fromX: 597 }
    }


    let knotBottom = {
		fromTopLeft: { fromY: 434, fromX: 635 },
    	fromTopRight: { fromY: 434, fromX: 655 },
		fromBottomRight: { fromY: 507, fromX: 653 },
		fromBottomLeft: { fromY: 506, fromX: 635 }
    }

    // keep !

    let knotHandAnother = {
    fromTopLeft: { fromY: 505, fromX: 401 },
      fromTopRight: { fromY: 505, fromX: 422 },
    fromBottomRight: { fromY: 577, fromX: 421 },
    fromBottomLeft: { fromY: 577, fromX: 402 }
    }

    let knotHand = {

      fromTopLeft: { fromY: 412, fromX: 347 },
      fromTopRight: { fromY: 412, fromX: 366 },
        fromBottomRight: { fromY: 486, fromX: 366 },
      fromBottomLeft: { fromY: 486, fromX: 347 }
      
    }

    let knotFootAnother = {
    fromTopLeft: { fromY: 297, fromX: 291 },
      fromTopRight: { fromY: 297, fromX: 309 },
    fromBottomRight: { fromY: 385, fromX: 306 },
    fromBottomLeft: { fromY: 384, fromX: 291 }

    }

    let knotFoot = {
    fromTopLeft: { fromY: 204, fromX: 376 },
      fromTopRight: { fromY: 205, fromX: 394 },
    fromBottomRight: { fromY: 292, fromX: 391 },
    fromBottomLeft: { fromY: 292, fromX: 375 }

    }
    constructKnot(knotHead)

    constructKnot(knotBody)

    constructKnot(knotBottom)

    constructKnot(knotHandAnother)
    constructKnot(knotHand)

    constructKnot(knotFootAnother)
    constructKnot(knotFoot)

    let fromPassdStackinCreatd = []

    let fromPassdStackinFromOriginal = []
    let fromPassdStackin = []

    let usePassThroughStackin /* keep */

    let knotThroughStackinLayer = {
      fromTopLeft: { fromY: 100, fromX: 1156 },
      fromTopRight: { fromY: 100, fromX: 1186 },
      fromBottomRight: { fromY: 125, fromX: 1186 },
      fromBottomLeft: { fromY: 125, fromX: 1155 }
    }

    let fromPassdRectCreatd = []

    let fromPassdRectFromOriginal = []
    let fromPassdRect = []

    let usePassThroughRect /* keep */

    let knotPassThroughRect = {
      fromTopLeft: { fromY: 143, fromX: 1156 },
      fromTopRight: { fromY: 143, fromX: 1187 },
      fromBottomRight: { fromY: 168, fromX: 1188 },
      fromBottomLeft: { fromY: 168, fromX: 1156 }
    }

    let knotPassIntoDebth = {
      fromTopLeft: { fromY: 142, fromX: 1245 },
      fromTopRight: { fromY: 142, fromX: 1276 },
      fromBottomRight: { fromY: 168, fromX: 1276 },
      fromBottomLeft: { fromY: 168, fromX: 1245 }
    }

    let knotPassIntoBoundin = {
      fromTopLeft: { fromY: 177, fromX: 1245 },
      fromTopRight: { fromY: 177, fromX: 1276 },
      fromBottomRight: { fromY: 202, fromX: 1276 },
      fromBottomLeft: { fromY: 202, fromX: 1244 }
    }



    let knotPassIntoLayer = {
      fromTopLeft: { fromY: 211, fromX: 1246 },
      fromTopRight: { fromY: 211, fromX: 1277 },
      fromBottomRight: { fromY: 236, fromX: 1276 },
      fromBottomLeft: { fromY: 236, fromX: 1245 }
    }

    let fromPassdLineFromOriginal = []
    let fromPassdLine = []

    let usePassThroughLine /* keep */
    let knotPassThroughLine = {
		fromTopLeft: { fromY: 211, fromX: 1154 },
    	fromTopRight: { fromY: 211, fromX: 1185 },
		fromBottomRight: { fromY: 237, fromX: 1185 },
		fromBottomLeft: { fromY: 237, fromX: 1155 }
    }
    let descendingFromTheSun = function(arr) {
        return JSON.parse(JSON.stringify(arr)).reverse()[0]
    }

  // keep !
  let knotSlotMiddleClosin = [
    { fromY: 403, fromX: 1478 },
    { fromY: 401, fromX: 1412 }
  ]

  let knotSlotMiddleStartinFrom = [
    { fromY: 691, fromX: 1482 },
    { fromY: 690, fromX: 1412 }
  ]

  // keep !
  let knotSlotClosin = [
    { fromY: 321, fromX: 1251 },
    { fromY: 321, fromX: 1182 }
  ]
  let knotSlotStartingFrom = [
    { fromY: 612, fromX: 1252 },
    { fromY: 611, fromX: 1182 }
  ]


  // keep !
  let knotSampleFootThroughStackinClosin = [
    { fromY: 57, fromX: 169 },
    { fromY: 57, fromX: 100 },
  ]
  let knotSampleFootThroughStackinStartingFrom = [
        { fromY: 348, fromX: 172 },
        { fromY: 348, fromX: 102 }
  ]

  let knotSampleFootThroughStackin = {
    fromTopLeft: { fromY: 23, fromX: 30 },
    fromTopRight: { fromY: 25, fromX: 245 },
    fromBottomRight: { fromY: 388, fromX: 239 },
    fromBottomLeft: { fromY: 389, fromX: 33 }
  }

  let queueFromPassdDebth = []

  let queueFromPassdStackd = []
  let queueFromPassdIntoBoundinFromOriginal = []
  let queueFromPassdIntoBoundin = []


  let queueFromPassdLine = []
  let queueFromPassdRect = []

    let knotFromFocus /* keep */

  let knotSlotStickd = {
	fromTopLeft: { fromY: 275, fromX: 1105 },
  	fromTopRight: { fromY: 269, fromX: 1567 },
	fromBottomRight: { fromY: 732, fromX: 1565 },
	fromBottomLeft: { fromY: 732, fromX: 1107 }
  }

  let knotWiFromKnotSlotStickd = knotSlotStickd.fromBottomRight.fromX - knotSlotStickd.fromBottomLeft.fromX
let profileFromKnotSlotStickd = knotSlotStickd.fromBottomRight.fromY - knotSlotStickd.fromTopLeft.fromY

  let knotSlotAnother = {
    fromTopLeft: { fromY: 355, fromX: 1349 },
    fromTopRight: { fromY: 359, fromX: 1559 },
    fromBottomRight: { fromY: 708, fromX: 1553 },
    fromBottomLeft: { fromY: 707, fromX: 1354 }
  }

  let knotSlot = {
    fromTopLeft: { fromY: 288, fromX: 1120 },
    fromTopRight: { fromY: 290, fromX: 1329 },
    fromBottomRight: { fromY: 643, fromX: 1321 },
    fromBottomLeft: { fromY: 643, fromX: 1123 }
  }

  let knotStickd = {
    fromTopLeft: { fromY: 75, fromX: 1138 },
    fromTopRight: { fromY: 75, fromX: 1280 },
    fromBottomRight: { fromY: 277, fromX: 1283 },  
    fromBottomLeft: { fromY: 277, fromX: 1128 }
  }

  let knotWiFromKnotStickd = knotStickd.fromBottomRight.fromX - knotStickd.fromBottomLeft.fromX
let profileFromKnotStickd = knotStickd.fromBottomRight.fromY - knotStickd.fromTopLeft.fromY

let knotIntoComputeWorkareaThroughSlot = {
  fromTopLeft: { fromY: 244, fromX: 1245 },
  fromTopRight: { fromY: 245, fromX: 1276 },
  fromBottomRight: { fromY: 270, fromX: 1276 },
  fromBottomLeft: { fromY: 270, fromX: 1245 }
}

let knotIntoCapturdWorkareaThroughSlot = {
  fromTopLeft: { fromY: 246, fromX: 1155 },
  fromTopRight: { fromY: 246, fromX: 1185 },
  fromBottomRight: { fromY: 271, fromX: 1188 },
  fromBottomLeft: { fromY: 271, fromX: 1155 }
}

let knotSampleFootBounddThroughRest = {
  fromTopLeft: { fromY: 230, fromX: 402 },
  fromTopRight: { fromY: 230, fromX: 414 },
  fromBottomRight: { fromY: 251, fromX: 414 },
  fromBottomLeft: { fromY: 251, fromX: 402 }
}
constructKnot(knotSampleFootBounddThroughRest)

let knotSampleFootBounddThroughAnother = {
  fromTopLeft: { fromY: 255, fromX: 402},
  fromTopRight: { fromY: 255, fromX: 414 },
  fromBottomRight: { fromY: 275, fromX: 414 },
  fromBottomLeft: { fromY: 275, fromX: 402 }
}
constructKnot(knotSampleFootBounddThroughAnother)

let knotSampleFootBounddFromStartin = {
  fromTopLeft: { fromY: 279, fromX: 402 },

  fromTopRight: { fromY: 279, fromX: 413 },
  
  fromBottomRight: { fromY: 292, fromX: 413 },
  
  fromBottomLeft: { fromY: 292, fromX: 401 }
  
}
constructKnot(knotSampleFootBounddFromStartin)

let knotSampleFootBounddIntoClosin = {
  fromTopLeft: { fromY: 205, fromX: 402 },

  fromTopRight: { fromY: 205, fromX: 414 },

  fromBottomRight: { fromY: 226, fromX: 414 },

  fromBottomLeft: { fromY: 226, fromX: 401 }
}
constructKnot(knotSampleFootBounddIntoClosin)


let queueStackinFromPassdFootBounddIntoClosin = [/* keep */]

let queueStackinFromPassdFootBounddThroughRest = [/* keep */]


let queueStackinFromPassdFootBounddThroughAnother = [/* keep */]

let usePassThroughFoot /* keep */
let queueStackinFromPassdFootBounddFromStartin = [/* keep */]


    // through stickd-album
	document.querySelector('.statement-area').querySelector('.statement-at-front').querySelector('#scene').addEventListener('click', function(event) {
	// keep !

	  let providedY = /* keep ! */ event.layerY
	  let providedX = event.layerX


    let pointerBelongings = knotSampleFootBounddIntoClosin

    if(
      'throughStackin' === usePassThroughStackin
       && "throughFootBounddIntoClosin" ===usePassThroughFoot

      && providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      queueStackinFromPassdFootBounddIntoClosin = [].concat(JSON.parse(JSON.stringify(queueFromPassdIntoBoundin)))
      
      usePassThroughFoot = ''

      constructKnot(knotSampleFootBounddIntoClosin)

      return /* keep */
    }


      if('throughStackin' === usePassThroughStackin && "throughFootBounddIntoClosin" ===usePassThroughFoot) {

        for(let i = 0; i < fromPassdRectCreatd.length; i++) {

          let fromPointerBelongings = {

            fromTopLeft: fromPassdRectCreatd[i][3],
            fromTopRight: fromPassdRectCreatd[i][2],
            fromBottomRight: fromPassdRectCreatd[i][1],
            fromBottomLeft: fromPassdRectCreatd[i][0]
          }

          if(
            providedY > fromPointerBelongings.fromTopLeft.fromY && providedX > fromPointerBelongings.fromTopLeft.fromX
            && providedY > fromPointerBelongings.fromTopRight.fromY && providedX < fromPointerBelongings.fromTopRight.fromX
            && providedY < fromPointerBelongings.fromBottomRight.fromY && providedX < fromPointerBelongings.fromBottomRight.fromX
            && providedY <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedX
          ) {
            queueFromPassdIntoBoundin.push(fromPointerBelongings)

            constructKnotThroughHighlightAbove(fromPointerBelongings)

            return /* keep */
          }

          
        }
      }

    if(
      providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      usePassThroughFoot = 'throughFootBounddIntoClosin'
      constructKnotThroughHighlight(knotSampleFootBounddIntoClosin)
    }

    // keep !

    /* let */ pointerBelongings = knotSampleFootBounddThroughRest


    if(
      'throughStackin' === usePassThroughStackin
       && "throughFootBounddThroughRest" ===usePassThroughFoot

      && providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      queueStackinFromPassdFootBounddThroughRest = [].concat(JSON.parse(JSON.stringify(queueFromPassdIntoBoundin)))
      
      usePassThroughFoot = ''

      constructKnot(knotSampleFootBounddThroughRest)

      return /* keep */
    }


      if('throughStackin' === usePassThroughStackin && "throughFootBounddThroughRest" ===usePassThroughFoot) {

        for(let i = 0; i < fromPassdRectCreatd.length; i++) {

          let fromPointerBelongings = {

            fromTopLeft: fromPassdRectCreatd[i][3],
            fromTopRight: fromPassdRectCreatd[i][2],
            fromBottomRight: fromPassdRectCreatd[i][1],
            fromBottomLeft: fromPassdRectCreatd[i][0]
          }

          if(
            providedY > fromPointerBelongings.fromTopLeft.fromY && providedX > fromPointerBelongings.fromTopLeft.fromX
            && providedY > fromPointerBelongings.fromTopRight.fromY && providedX < fromPointerBelongings.fromTopRight.fromX
            && providedY < fromPointerBelongings.fromBottomRight.fromY && providedX < fromPointerBelongings.fromBottomRight.fromX
            && providedY <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedX
          ) {
            queueFromPassdIntoBoundin.push(fromPointerBelongings)

            constructKnotThroughHighlightAbove(fromPointerBelongings)

            return /* keep */
          }

          
        }
      }

    if(
      providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      usePassThroughFoot = 'throughFootBounddThroughRest'
      constructKnotThroughHighlight(knotSampleFootBounddThroughRest)
    }


    /* let */ pointerBelongings = knotSampleFootBounddThroughAnother

    if(
      'throughStackin' === usePassThroughStackin
       && "throughFootBounddThroughAnother" ===usePassThroughFoot

      && providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      queueStackinFromPassdFootBounddThroughAnother = [].concat(JSON.parse(JSON.stringify(queueFromPassdIntoBoundin)))
      
      usePassThroughFoot = ''

      constructKnot(knotSampleFootBounddThroughAnother)

      return /* keep */
    }


      if('throughStackin' === usePassThroughStackin && "throughFootBounddThroughAnother" ===usePassThroughFoot) {

        for(let i = 0; i < fromPassdRectCreatd.length; i++) {

          let fromPointerBelongings = {

            fromTopLeft: fromPassdRectCreatd[i][3],
            fromTopRight: fromPassdRectCreatd[i][2],
            fromBottomRight: fromPassdRectCreatd[i][1],
            fromBottomLeft: fromPassdRectCreatd[i][0]
          }

          if(
            providedY > fromPointerBelongings.fromTopLeft.fromY && providedX > fromPointerBelongings.fromTopLeft.fromX
            && providedY > fromPointerBelongings.fromTopRight.fromY && providedX < fromPointerBelongings.fromTopRight.fromX
            && providedY < fromPointerBelongings.fromBottomRight.fromY && providedX < fromPointerBelongings.fromBottomRight.fromX
            && providedY <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedX
          ) {
            queueFromPassdIntoBoundin.push(fromPointerBelongings)

            constructKnotThroughHighlightAbove(fromPointerBelongings)

            return /* keep */
          }

          
        }
      }

    if(
      providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      usePassThroughFoot = 'throughFootBounddThroughAnother'
      constructKnotThroughHighlight(knotSampleFootBounddThroughAnother)
    }


    /* let */ pointerBelongings = knotSampleFootBounddFromStartin


    if(
      'throughStackin' === usePassThroughStackin
       && "throughFootBounddFromStartin" ===usePassThroughFoot

      && providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      queueStackinFromPassdFootBounddFromStartin = [].concat(JSON.parse(JSON.stringify(queueFromPassdIntoBoundin)))
      
      usePassThroughFoot = ''

      constructKnot(knotSampleFootBounddFromStartin)

      return /* keep */
    }


      if('throughStackin' === usePassThroughStackin && "throughFootBounddFromStartin" ===usePassThroughFoot) {

        for(let i = 0; i < fromPassdRectCreatd.length; i++) {

          let fromPointerBelongings = {

            fromTopLeft: fromPassdRectCreatd[i][3],
            fromTopRight: fromPassdRectCreatd[i][2],
            fromBottomRight: fromPassdRectCreatd[i][1],
            fromBottomLeft: fromPassdRectCreatd[i][0]
          }

          if(
            providedY > fromPointerBelongings.fromTopLeft.fromY && providedX > fromPointerBelongings.fromTopLeft.fromX
            && providedY > fromPointerBelongings.fromTopRight.fromY && providedX < fromPointerBelongings.fromTopRight.fromX
            && providedY < fromPointerBelongings.fromBottomRight.fromY && providedX < fromPointerBelongings.fromBottomRight.fromX
            && providedY <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedX
          ) {
            queueFromPassdIntoBoundin.push(fromPointerBelongings)

            constructKnotThroughHighlightAbove(fromPointerBelongings)

            return /* keep */
          }

          
        }
      }


    if(
      providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {

      usePassThroughFoot = 'throughFootBounddFromStartin'
      constructKnotThroughHighlight(knotSampleFootBounddFromStartin)

      return /* keep */

      // alert("sample")
    }

    /* let */ pointerBelongings = knotIntoComputeWorkareaThroughSlot 

    if(
      providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {

      // let fromPrompt = function(/* keep */ question) {
      //   return function() {
      //     return prompt(question)
      //   }
      // }
      // let solve = function(arr) {
      //   return arr.map(function(fq) {
      //     fq()
      //   })
      // }

      // let questions = Array.from([
      //   fromPrompt("stackd"),
      //   fromPrompt("rect"),
      //   fromPrompt("line")
      // ].reverse())

      // let provided = solve(questions)

      // let [queueFromPassdLine, queueFromPassdRect, queueFromPassdStackd] = [JSON.parse(provided.slice(0, 1)), JSON.parse(provided.slice(1, 2)), JSON.parse(provided.slice(1, 2))]


    }

    /* let */ pointerBelongings = knotIntoCapturdWorkareaThroughSlot


    if(
      providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      // keep !
      // alert("sample")
      let intoString16 = function(fromPassd, fromLabel) {

      let fromPassdLine = fromPassd

      // alert(JSON.stringify(fromPassdLine))
      // console.log(fromPassd.split('|'))

      fromPassdStr = [].concat("----closin4line----").concat(fromPassdLine).concat("----startin8from8line----").join("")

      fromPassdStr = fromPassdStr.split("").map(function(char){ return char.charCodeAt().toString(16) })

      let fromBottom = function(fromPassd) {
        return Math.floor(fromPassd)
      }

      // console.log(fromPassdStr)
      // alert(JSON.stringify(fromPassdStr))
      // 2*8
      let computeFromRemainin = function(fromPassdStr) {

        // console.log("fromPassdStr", fromPassdStr)

      let fromLineIntermediateFromOriginal = []
      let intoLineIntermediate = []
      let intoLineRemainin = []

      // fromBottom(fromPassdStr.length / calc(2 * 8))

      let fromPassdStrFromOriginal = fromBottom(fromPassdStr.length / calc(2 * 8)) * calc(2 * 8)

      let fromPassdStrAnother = fromPassdStrFromOriginal + (fromPassdStr.length - fromPassdStrFromOriginal.length) / calc(8) * calc(8)

      for(let i = fromBottom(fromPassdStr.length / calc(2 * 8) * calc(2 * 8)); i < fromPassdStrAnother; i+=8) {

        let fromLine = [].concat(

          [
            [
              fromPassdStr[i+7],
              fromPassdStr[i+6]
            ].reverse().join(""),
            [
              fromPassdStr[i+5],
              fromPassdStr[i+4]
            ].reverse().join(""),
            [
              fromPassdStr[i+3],
              fromPassdStr[i+2]
            ].reverse().join(""),
            [        
              fromPassdStr[i+1],
              fromPassdStr[i]
            ].reverse().join("")
          ].reverse(),

          // keep

        )
        if(fromLineIntermediate.length) {
          intoLineRemainin.push([].concat(fromLineIntermediate).concat(fromLine.join(" ")))
          fromLineIntermediate = JSON.parse(JSON.stringify(fromLineIntermediateFromOriginal))
          continue
        }
        fromLineIntermediate.push(fromLine.join(" "))
        }
        // if(fromLineIntermediate.length) {
        //   intoLineRemainin.push([].concat(fromLineIntermediate))
        // }

        let intoLinePd = []
        fromLineIntermediate = []

        for(let i = fromBottom(fromPassdStrAnother); i < fromPassdStr.length; i+=2) {

          let fromPd = [        
            fromPassdStr[i+1],
            fromPassdStr[i]
          ].reverse().join("")

          if(fromLineIntermediate.length) {
            intoLinePd.push(
              [].concat(fromLineIntermediate).concat(fromPd).join('')
            )
            fromLineIntermediate = JSON.parse(JSON.stringify(fromLineIntermediateFromOriginal))
          }
          fromLineIntermediate.push(fromPd)
        }


      // if(fromLineIntermediate.length) {
        //   intoLineRemainin.push([].concat(fromLineIntermediate))
        // }

        return [].concat(intoLineRemainin.join('\n')).concat(intoLinePd.join(' '))
      }


      let intoLine = []
      for(let i = 0; i < fromBottom(fromPassdStr.length / calc(2 * 8)) * calc(2 * 8); i+=(2 * 8)) {

        let fromLine = [].concat(


          [
            [
              fromPassdStr[i+7],
              fromPassdStr[i+6]
            ].reverse().join(""),
            [
              fromPassdStr[i+5],
              fromPassdStr[i+4]
            ].reverse().join(""),
            [
              fromPassdStr[i+3],
              fromPassdStr[i+2]
            ].reverse().join(""),
            [        
              fromPassdStr[i+1],
              fromPassdStr[i]
            ].reverse().join("")
          ].reverse(),

          [
            [
              fromPassdStr[i+15],
              fromPassdStr[i+14]
            ].reverse().join(""),

            [
              fromPassdStr[i+12+1],
              fromPassdStr[i+12]
            ].reverse().join(""),

            [
              fromPassdStr[i+11],
              fromPassdStr[i+10]
            ].reverse().join(""),
            [
              fromPassdStr[i+9],
              fromPassdStr[i+8]
            ].reverse().join(""),
          ].reverse()

        )
        // console.log(fromLine.join(" "))
        intoLine.push(fromLine.join(" "))

        }
        // console.log(intoLine)

        // let fromPassdStrRemainin = fromPassdStr.slice(fromBottom(fromPassdStr.length / (2 * calc(8)) * (2 * calc(8)))).length ? fromPassdStr.slice(fromBottom(fromPassdStr.length / (2 * calc(8)) * (2 * calc(8)))).reduce(function(fromA, fromB) {
        //   return fromA.length === 4 ? [].concat(fromA).concat(fromB).join(" ") : [].concat(fromA).concat(fromB).join("")
        // }) : [].join("")
        // intoLine.push(fromPassdStrRemainin)

        // return intoLine.join("\n")
        // console.log(intoLine)

        let fromLineRemainin = computeFromRemainin(fromPassdStr)
        console.log(fromLineRemainin)


        return [].concat(intoLine).concat(fromLineRemainin).join("\n")
      }

      let fromPassdLine = JSON.stringify(queueFromPassdLine)

      fromPassdStr = [].concat("----closin4line----").concat(fromPassdLine).concat("----startin8from8line----").join("")

      fromPassdStr = fromPassdStr.split("").map(function(char){ return char.charCodeAt().toString(16) })

      let intoLine = []
      for(let i = 0; i < fromPassdStr.length / 8; i++) {

        let fromLine = [].concat(

          [
            [
              fromPassdStr[i+15],
              fromPassdStr[i+14]
            ].join(""),

            [
              fromPassdStr[i+12+1],
              fromPassdStr[i+12]
            ].join(""),

            [
              fromPassdStr[i+11],
              fromPassdStr[i+10]
            ].join(""),
            [
              fromPassdStr[i+9],
              fromPassdStr[i+8]
            ].join(""),
          ],

          [
            [
              fromPassdStr[i+7],
              fromPassdStr[i+6]
            ].join(""),
            [
              fromPassdStr[i+5],
              fromPassdStr[i+4]
            ].join(""),
            [
              fromPassdStr[i+3],
              fromPassdStr[i+2]
            ].join(""),
            [        
              fromPassdStr[i+1],
              fromPassdStr[i]
            ].join("")
          ]

        )
        // keep !
        intoLine.push(fromLine.join(" "))

      }


      // console.log(JSON.stringify(queueStackinFromPassdFootBounddIntoClosin))

      // console.log(JSON.stringify(queueStackinFromPassdFootBounddThroughRest))

      // console.log(JSON.stringify(queueStackinFromPassdFootBounddThroughAnother))

      // console.log(JSON.stringify(queueStackinFromPassdFootBounddFromStartin))


      // console.log(JSON.stringify(queueFromPassdStackd))
      // console.log(JSON.stringify(queueFromPassdRect))
      // console.log(JSON.stringify(queueFromPassdLine))

      let fromCapturdLine =  intoString16([]
        .concat([
          
          JSON.stringify(queueStackinFromPassdFootBounddIntoClosin),

          JSON.stringify(queueStackinFromPassdFootBounddThroughRest),

          JSON.stringify(queueStackinFromPassdFootBounddThroughAnother),

          JSON.stringify(queueStackinFromPassdFootBounddFromStartin)
      ]).concat(JSON.stringify(queueFromPassdStackd)).concat(JSON.stringify(queueFromPassdRect)).concat(JSON.stringify(queueFromPassdLine)).join("|"))


      alert(fromCapturdLine)

      // through await

      fetch(document.querySelector('.into-focus').src)
      .then(function(resp) {
        return resp.blob()
      }).then(function(b) {
        return new Blob([b, fromCapturdLine], {"Content-Type": "text/plain"})
      }).then(function(t) {
        let sampleLinkIntoSampleFootBoundd = document.createElement('a')

        sampleLinkIntoSampleFootBoundd.href = URL.createObjectURL(t)

        // id
        sampleLinkIntoSampleFootBoundd.download = "sample-slot-foot-boundd.png"

        sampleLinkIntoSampleFootBoundd.click()

      })
      

      // console.log(JSON.stringify(queueFromPassdStackd))
      // console.log(JSON.stringify(queueFromPassdRect))
      // console.log(JSON.stringify(queueFromPassdLine))
    }

    // use pass through debth
    /* let */ pointerBelongings = knotSampleFootThroughStackin

    if(
      providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
      && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
      && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
      && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
    ) {
      // keep !
      // constructKnot(knotSampleFootThroughStackin)

      let fromStackdFromOriginal = []
      let fromStackd = []

      for(let i = 0; i < queueFromPassdIntoBoundin.length; i++) {
        let fromPointerBelongings = queueFromPassdIntoBoundin[i] 

        for(let j = 0; j < queueFromPassdLine.length; j++) {


          let providedYThroughLine = queueFromPassdLine[j][1].fromY /* keep + */ - queueFromPassdLine[j][0].fromY ? calc(queueFromPassdLine[j][1].fromY + calc(queueFromPassdLine[j][1].fromY - queueFromPassdLine[j][0].fromY) * 0.5) : calc(queueFromPassdLine[j][0].fromY /* keep + */ - calc(queueFromPassdLine[j][0].fromY - queueFromPassdLine[j][1].fromY) * 0.5)

          let providedXThroughLine = queueFromPassdLine[j][1].fromX > queueFromPassdLine[j][0].fromX ? calc(queueFromPassdLine[j][0].fromX + calc(queueFromPassdLine[j][1].fromX - queueFromPassdLine[j][0].fromX) * 0.5) : calc(queueFromPassdLine[j][1].fromX + calc(queueFromPassdLine[j][0].fromX - queueFromPassdLine[j][1].fromX) * 0.5)

          // let queueFromPassdLine[j]
          // alert(JSON.stringify(fromPointerBelongings))

          // alert(JSON.stringify({providedYThroughLine, providedXThroughLine}))
          

          // console.log(providedYThroughLine <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedXThroughLine)

          if(
            providedYThroughLine > fromPointerBelongings.fromTopLeft.fromY && providedXThroughLine > fromPointerBelongings.fromTopLeft.fromX
            && providedYThroughLine > fromPointerBelongings.fromTopRight.fromY && providedXThroughLine < fromPointerBelongings.fromTopRight.fromX
            && providedYThroughLine < fromPointerBelongings.fromBottomRight.fromY && providedXThroughLine < fromPointerBelongings.fromBottomRight.fromX
            && providedYThroughLine <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedXThroughLine
          ) {

            let fromSlotPointerBelongings = knotSlot

          let providedYThroughSampleThroughStackin
          let providedXThroughSampleThroughStackin

          let passdThroughSlot

             if(
          providedYThroughLine > fromSlotPointerBelongings.fromTopLeft.fromY && providedXThroughLine > fromSlotPointerBelongings.fromTopLeft.fromX
          && providedYThroughLine > fromSlotPointerBelongings.fromTopRight.fromY && providedXThroughLine < fromSlotPointerBelongings.fromTopRight.fromX
          && providedYThroughLine < fromSlotPointerBelongings.fromBottomRight.fromY && providedXThroughLine < fromSlotPointerBelongings.fromBottomRight.fromX
          && providedYThroughLine <= fromSlotPointerBelongings.fromBottomLeft.fromY  && fromSlotPointerBelongings.fromBottomLeft.fromX < providedXThroughLine
        ) {

            passdThroughSlot = 'knotSlot'

            /* let */ providedYThroughSampleThroughStackin = calc(descendingFromTheSun(knotSampleFootThroughStackinStartingFrom.slice(0, 1)).fromY - calc(descendingFromTheSun(knotSlotStartingFrom.slice(0, 1)).fromY - providedYThroughLine))
            /* let */ providedXThroughSampleThroughStackin = descendingFromTheSun(knotSampleFootThroughStackinStartingFrom.slice(0, 1)).fromX + calc(providedXThroughLine - descendingFromTheSun(knotSlotStartingFrom.slice(0, 1)).fromX)
        }

        fromSlotPointerBelongings = knotSlotAnother
        if('knotSlot' === passdThroughSlot) {
          // keep !
        } else if(
          providedYThroughLine > fromSlotPointerBelongings.fromTopLeft.fromY && providedXThroughLine > fromSlotPointerBelongings.fromTopLeft.fromX
          && providedYThroughLine > fromSlotPointerBelongings.fromTopRight.fromY && providedXThroughLine < fromSlotPointerBelongings.fromTopRight.fromX
          && providedYThroughLine < fromSlotPointerBelongings.fromBottomRight.fromY && providedXThroughLine < fromSlotPointerBelongings.fromBottomRight.fromX
          && providedYThroughLine <= fromSlotPointerBelongings.fromBottomLeft.fromY  && fromSlotPointerBelongings.fromBottomLeft.fromX < providedXThroughLine
        ) {
            /* let */ providedYThroughSampleThroughStackin = calc(descendingFromTheSun(knotSampleFootThroughStackinStartingFrom.slice(0, 1)).fromY - calc(descendingFromTheSun(knotSlotMiddleStartinFrom.slice(0, 1)).fromY - providedYThroughLine))
            /* let */ providedXThroughSampleThroughStackin = descendingFromTheSun(knotSampleFootThroughStackinStartingFrom.slice(0, 1)).fromX + calc(providedXThroughLine - descendingFromTheSun(knotSlotMiddleStartinFrom.slice(0, 1)).fromX)
        } 

            fromStackd.push({
              fromX: providedXThroughSampleThroughStackin,
              fromY: providedYThroughSampleThroughStackin
            })
            
            if(fromStackd.length === 2) {
              queueFromPassdStackd.push(fromStackd)
              constructKnotSample(fromStackd)

              fromStackd = JSON.parse(JSON.stringify(fromStackdFromOriginal))

              return /* keep */
            }
            // keep !
          }

        }
      }

    }

    if('throughStackin' === usePassThroughStackin) {
      for(let i = 0; i < fromPassdRectCreatd.length; i++) {

        let fromPointerBelongings = {

          fromTopLeft: fromPassdRectCreatd[i][3],
          fromTopRight: fromPassdRectCreatd[i][2],
          fromBottomRight: fromPassdRectCreatd[i][1],
          fromBottomLeft: fromPassdRectCreatd[i][0]
        }

        if(
          providedY > fromPointerBelongings.fromTopLeft.fromY && providedX > fromPointerBelongings.fromTopLeft.fromX
          && providedY > fromPointerBelongings.fromTopRight.fromY && providedX < fromPointerBelongings.fromTopRight.fromX
          && providedY < fromPointerBelongings.fromBottomRight.fromY && providedX < fromPointerBelongings.fromBottomRight.fromX
          && providedY <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedX
        ) {
          queueFromPassdIntoBoundin.push(fromPointerBelongings)

          constructKnotThroughHighlightAbove(fromPointerBelongings)


          return /* keep */
        }

        
      }
    }

    pointerBelongings = knotThroughStackinLayer
    if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {
      if(usePassThroughStackin) {
      	fromCtx(ctx).fillRect(knotSlotStickd.fromBottomLeft.fromY, knotSlotStickd.fromBottomLeft.fromX, 
          knotWiFromKnotSlotStickd, profileFromKnotSlotStickd)

      	queueFromPassdIntoBoundin = JSON.parse(JSON.stringify(queueFromPassdIntoBoundinFromOriginal))

      	for(let i = 0; i < queueFromPassdRect.length; i++) {

        	constructKnotSampleThroughDraft(queueFromPassdRect[i])
      	}

      	for(let i = 0; i < queueFromPassdLine.length; i++) {

        	constructKnotSampleThroughHighlight(queueFromPassdLine[i])
      	}

        fromCtx(ctx).fillRect(knotStickd.fromBottomLeft.fromY, knotStickd.fromBottomLeft.fromX, 
          knotWiFromKnotStickd, profileFromKnotStickd)

        for(let i = 0; i < queueFromPassdStackd.length; i++) {
        	constructKnotSample(queueFromPassdStackd[i])

        }

        // constructKnotThroughDraft(knotThroughStackinLayer)  
        usePassThroughStackin = ''

        return /* keep */
      }
      // queueFromPassdIntoBoundin.push(knotThroughStackinLayer)
      // keep

      usePassThroughStackin = 'throughStackin'

      constructKnotThroughHighlight(knotThroughStackinLayer)
    }


    if('throughRect' === usePassThroughRect) {
      fromPassdRect.push({
        fromY: providedY,
        fromX: providedX
      })

      if(fromPassdRect.length === 4) {
      	// keep j
      	let fromPassdLine = [].concat(fromPassdRect[0]).concat(fromPassdRect[1])

  		let providedYThroughLine = fromPassdLine[1].fromY > fromPassdLine[0].fromY ? calc(fromPassdLine[1].fromY /* keep + */ - calc(fromPassdLine[1].fromY - fromPassdLine[0].fromY) * 0.5) : calc(fromPassdLine[0].fromY - /* keep + */ calc(fromPassdLine[0].fromY - fromPassdLine[1].fromY) * 0.5)

  		let diffFromPassdLineFromY = fromPassdLine[1].fromY > fromPassdLine[0].fromY ? calc(calc(fromPassdLine[1].fromY - fromPassdLine[0].fromY) * 0.5) : calc(calc(fromPassdLine[0].fromY - fromPassdLine[1].fromY) * 0.5)

      	if(diffFromPassdLineFromY > 100 * 0.2) {
      		fromPassdLine = JSON.parse(JSON.stringify(fromPassdLineFromOriginal))

      		return /* keep */
      	}

      	queueFromPassdRect.push([].concat(fromPassdRect).concat(descendingFromTheSun(fromPassdRect.slice(0, 1))))

        let knotSampleThroughDraft = [].concat(fromPassdRect).concat(descendingFromTheSun(fromPassdRect.slice(0, 1)))
        fromPassdRectCreatd.push(knotSampleThroughDraft)

        constructKnotSampleThroughDraft(knotSampleThroughDraft)

        fromPassdRect = JSON.parse(JSON.stringify(fromPassdRectFromOriginal))
        /* keep from original*/
      }
    }

    /* let */ pointerBelongings = knotPassThroughRect
    if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {
      if(usePassThroughRect) {

        fromCtx(ctx).fillRect(knotStickd.fromBottomLeft.fromY, knotStickd.fromBottomLeft.fromX, 
          knotWiFromKnotStickd, profileFromKnotStickd)

        fromPassdRect = JSON.parse(JSON.stringify(fromPassdRectFromOriginal))
        // constructKnotThroughDraft(knotPassThroughRect)  
        usePassThroughRect = ''

        return /* keep */
      }

      usePassThroughRect = 'throughRect'
      constructKnotThroughHighlight(knotPassThroughRect)
    }

    // queuePassdIntoDebth
    /* let */ pointerBelongings = knotPassIntoDebth
    if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {
      constructKnotThroughHighlight(knotPassIntoDebth)
    }

    /* let */ pointerBelongings = knotPassIntoBoundin
    if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {

      let fromStackdFromOriginal = []
      let fromStackd = []
      
      for(let i = 0; i < queueFromPassdIntoBoundin.length; i++) {
      	let fromPointerBelongings = queueFromPassdIntoBoundin[i] 

      	for(let j = 0; j < queueFromPassdLine.length; j++) {

      		let providedYThroughLine = queueFromPassdLine[j][1].fromY > queueFromPassdLine[j][0].fromY ? calc(queueFromPassdLine[j][1].fromY + calc(queueFromPassdLine[j][1].fromY - queueFromPassdLine[j][0].fromY) * 0.5) : calc(queueFromPassdLine[j][0].fromY + calc(queueFromPassdLine[j][0].fromY - queueFromPassdLine[j][1].fromY) * 0.5)

      		let providedXThroughLine = queueFromPassdLine[j][1].fromX > queueFromPassdLine[j][0].fromX ? calc(queueFromPassdLine[j][0].fromX + calc(queueFromPassdLine[j][1].fromX - queueFromPassdLine[j][0].fromX) * 0.5) : calc(queueFromPassdLine[j][1].fromX + calc(queueFromPassdLine[j][0].fromX - queueFromPassdLine[j][1].fromX) * 0.5)

      		// let queueFromPassdLine[j]
      		// alert(JSON.stringify(fromPointerBelongings))

      		// alert(JSON.stringify({providedYThroughLine, providedXThroughLine}))
      		

      		// console.log(providedYThroughLine <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedXThroughLine)

      		if(
	          providedYThroughLine > fromPointerBelongings.fromTopLeft.fromY && providedXThroughLine > fromPointerBelongings.fromTopLeft.fromX
	          && providedYThroughLine > fromPointerBelongings.fromTopRight.fromY && providedXThroughLine < fromPointerBelongings.fromTopRight.fromX
	          && providedYThroughLine < fromPointerBelongings.fromBottomRight.fromY && providedXThroughLine < fromPointerBelongings.fromBottomRight.fromX
	          && providedYThroughLine <= fromPointerBelongings.fromBottomLeft.fromY  && fromPointerBelongings.fromBottomLeft.fromX < providedXThroughLine
	        ) {
	        	fromStackd.push({
	        		fromX: providedXThroughLine,
	        		fromY: providedYThroughLine
	        	})
	        	
	        	if(fromStackd.length === 2) {
	        		queueFromPassdStackd.push(fromStackd)
	        		constructKnotSample(fromStackd)

	        		fromStackd = JSON.parse(JSON.stringify(fromStackdFromOriginal))

	        		return /* keep */
	        	}
	        	// keep !
      		}

      	}
      }

      constructKnotThroughHighlight(knotPassIntoBoundin)
    }
    

    /* let */ pointerBelongings = knotPassIntoLayer
    if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {
      constructKnotThroughHighlight(knotPassIntoLayer)
    }
    // through statement-area-closin

    if('throughLine' === usePassThroughLine) {
      fromPassdLine.push({
        fromY: providedY,
        fromX: providedX
      })

      if(fromPassdLine.length === 2) {
      	// keep j
  		let providedYThroughLine = fromPassdLine[1].fromY > fromPassdLine[0].fromY ? calc(fromPassdLine[1].fromY + calc(fromPassdLine[1].fromY - fromPassdLine[0].fromY) * 0.5) : calc(fromPassdLine[0].fromY + calc(fromPassdLine[0].fromY - fromPassdLine[1].fromY) * 0.5)

  		let diffFromPassdLineFromY = fromPassdLine[1].fromY > fromPassdLine[0].fromY ? calc(calc(fromPassdLine[1].fromY - fromPassdLine[0].fromY) * 0.5) : calc(calc(fromPassdLine[0].fromY - fromPassdLine[1].fromY) * 0.5)

      if(fromPassdLine[1].fromX > fromPassdLine[0].fromX) {
        // keep
      } else {
        fromPassdLine = JSON.parse(JSON.stringify(fromPassdLineFromOriginal))

        return /* keep */
      }

      	if(diffFromPassdLineFromY > 100 * 0.2) {
      		fromPassdLine = JSON.parse(JSON.stringify(fromPassdLineFromOriginal))

      		return /* keep */
      	}

      	queueFromPassdLine.push(fromPassdLine)
      	//

        constructKnotSampleThroughHighlight(fromPassdLine)

        fromPassdLine = JSON.parse(JSON.stringify(fromPassdLineFromOriginal))
        /* keep from original*/
      }
    }

	  /* let */ pointerBelongings = knotPassThroughLine
	  if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {
      if(usePassThroughLine) {

        fromCtx(ctx).fillRect(knotStickd.fromBottomLeft.fromY, knotStickd.fromBottomLeft.fromX, 
          knotWiFromKnotStickd, profileFromKnotStickd)

        // constructKnotThroughDraft(knotPassThroughLine)
        usePassThroughLine = ''

        return /* keep */
      }
      usePassThroughLine = 'throughLine'
	  	constructKnotThroughHighlight(knotPassThroughLine)
	  }

	  // keep !

	  /* let */ pointerBelongings = knotHandAnother
	  if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {
	  		document.querySelector('.sample-slot-hand').classList.remove('into-focus')
	  		document.querySelector('.sample-slot-foot-another').classList.remove('into-focus')
	  		document.querySelector('.sample-slot-foot').classList.remove('into-focus')
	  		document.querySelector('.sample-slot-hand-another').classList.add('into-focus')
	  		constructKnot(knotHand)
	  		constructKnot(knotFootAnother)
	  		constructKnot(knotFoot)
      		constructKnotThroughHighlight(knotHandAnother)
      	}

	  /* let */ pointerBelongings = knotHand
	  if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {
	  		document.querySelector('.sample-slot-hand-another').classList.remove('into-focus')
	  		document.querySelector('.sample-slot-foot-another').classList.remove('into-focus')
	  		document.querySelector('.sample-slot-foot').classList.remove('into-focus')
	  		document.querySelector('.sample-slot-hand').classList.add('into-focus')
	  		constructKnot(knotHandAnother)
	  		constructKnot(knotFootAnother)
	  		constructKnot(knotFoot)
      		constructKnotThroughHighlight(knotHand)
      	}


	  /* let */ pointerBelongings = knotFootAnother

      if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {

          document.querySelector('.sample-slot-hand-another').classList.remove('into-focus')
          document.querySelector('.sample-slot-hand').classList.remove('into-focus')
          // keep !
      		document.querySelector('.sample-slot-foot').classList.remove('into-focus')
      		document.querySelector('.sample-slot-foot-another').classList.add('into-focus')
      		constructKnot(knotHandAnother)
      		constructKnot(knotHand)
      		constructKnot(knotFoot)
      		constructKnotThroughHighlight(knotFootAnother)
      	}
	

	  /* let */ pointerBelongings = knotFoot

      if(
          providedY > pointerBelongings.fromTopLeft.fromY && providedX > pointerBelongings.fromTopLeft.fromX
          && providedY > pointerBelongings.fromTopRight.fromY && providedX < pointerBelongings.fromTopRight.fromX
          && providedY < pointerBelongings.fromBottomRight.fromY && providedX < pointerBelongings.fromBottomRight.fromX
          && providedY <= pointerBelongings.fromBottomLeft.fromY  && pointerBelongings.fromBottomLeft.fromX < providedX
        ) {

          document.querySelector('.sample-slot-hand-another').classList.remove('into-focus')
          document.querySelector('.sample-slot-hand').classList.remove('into-focus')
          // keep
      		document.querySelector('.sample-slot-foot-another').classList.remove('into-focus')
        	document.querySelector('.sample-slot-foot').classList.add('into-focus')
        	constructKnot(knotHandAnother)
        	constructKnot(knotHand)
        	constructKnot(knotFootAnother)
      		constructKnotThroughHighlight(knotFoot)
      	}
	})
	// keep !




</script>

</body>
</html>